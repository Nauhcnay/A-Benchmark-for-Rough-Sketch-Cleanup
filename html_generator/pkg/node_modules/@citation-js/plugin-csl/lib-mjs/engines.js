import CSL from 'citeproc';
import { templates } from './styles';
import { locales } from './locales';
const proxied = Symbol.for('proxied');

const getWrapperProxy = function (original) {
  const proxy = function (state, entry) {
    if (state.sys.wrapBibliographyEntry) {
      let [prefix, postfix] = state.sys.wrapBibliographyEntry(this.system_id);
      entry = [prefix, entry, postfix].join('');
    }

    return original.call(this, state, entry);
  };

  proxy[proxied] = true;
  return proxy;
};

for (let format in CSL.Output.Formats) {
  let original = CSL.Output.Formats[format]['@bibliography/entry'];

  if (!original || original[proxied]) {
    continue;
  }

  CSL.Output.Formats[format]['@bibliography/entry'] = getWrapperProxy(original);
}

const engines = {};

const fetchEngine = function (style, lang, template, retrieveItem, retrieveLocale) {
  const engineHash = `${style}|${lang}`;
  let engine;

  if (engines.hasOwnProperty(engineHash)) {
    engine = engines[engineHash];
    engine.sys.retrieveItem = retrieveItem;
  } else {
    engine = engines[engineHash] = new CSL.Engine({
      retrieveLocale,
      retrieveItem
    }, template, lang, true);
  }

  return engine;
};

const prepareEngine = function (data, templateName, language, format) {
  const items = data.reduce((store, entry) => {
    store[entry.id] = entry;
    return store;
  }, {});
  const template = templates.get(templates.has(templateName) ? templateName : 'apa');
  language = locales.has(language) ? language : 'en-US';
  const engine = fetchEngine(templateName, language, template, key => items[key], locales.get.bind(locales));
  engine.setOutputFormat(format);
  return engine;
};

export default prepareEngine;
export { fetchEngine };