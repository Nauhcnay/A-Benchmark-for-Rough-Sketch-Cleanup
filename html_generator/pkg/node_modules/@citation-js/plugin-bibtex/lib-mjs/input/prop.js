import { logger } from '@citation-js/core';
import { parse as parseName } from '@citation-js/name';
import { parse as parseDate } from '@citation-js/date';
const months = [/jan(uary)?\.?/i, /feb(ruary)?\.?/i, /mar(ch)?\.?/i, /apr(il)?\.?/i, /may\.?/i, /jun(e)?\.?/i, /jul(y)?\.?/i, /aug(ust)?\.?/i, /sep(tember)?\.?/i, /oct(ober)?\.?/i, /nov(ember)?\.?/i, /dec(ember)?\.?/i];

const parseBibtexDate = function (value) {
  if (/{|}/.test(value)) {
    return {
      literal: value.replace(/[{}]/g, '')
    };
  } else if (/[—–]/.test(value)) {
    return {
      'date-parts': value.split(/[—–]/).map(part => parseDate(part)['date-parts'][0])
    };
  } else {
    return parseDate(value);
  }
};

const parseBibtexName = function (name) {
  if (/{|}/.test(name)) {
    return {
      literal: name.replace(/[{}]/g, '')
    };
  } else {
    return parseName(name);
  }
};

const parseBibtexNameList = function (list) {
  const literals = [];
  list = list.replace(/%/g, '%0').replace(/{.*?}/g, m => `%[${literals.push(m) - 1}]`);
  return list.split(' and ').map(name => name.replace(/%\[(\d+)\]/g, (_, i) => literals[+i]).replace(/%0/g, '%')).map(parseBibtexName);
};

const richTextMappings = {
  textit: 'i',
  textbf: 'b',
  textsc: 'sc',
  textsuperscript: 'sup',
  textsubscript: 'sub'
};

const parseBibtexRichText = function (text) {
  let tokens = text.split(/((?:\\[a-z]+)?{|})/);
  let closingTags = [];
  let hasTopLevelTag = text[0] === '{' && text[text.length - 1] === '}';
  tokens = tokens.map((token, index) => {
    if (index % 2 === 0) {
      return token;
    } else if (token[0] === '\\') {
      let tag = richTextMappings[token.slice(1, -1)];

      if (tag) {
        closingTags.push(`</${tag}>`);
        return `<${tag}>`;
      } else {
        closingTags.push('');
        return '';
      }
    } else if (token === '{') {
      closingTags.push('</span>');
      return '<span class="nocase">';
    } else if (token === '}') {
      if (closingTags.length === 1 && index !== tokens.length - 2) {
        hasTopLevelTag = false;
      }

      return closingTags.pop();
    }
  });

  if (hasTopLevelTag) {
    tokens.splice(0, 2);
    tokens.splice(-2, 2);
  }

  return tokens.join('');
};

const propMap = {
  address: 'publisher-place',
  author: true,
  booktitle: 'container-title',
  doi: 'DOI',
  date: 'issued',
  edition: true,
  editor: true,
  isbn: 'ISBN',
  issn: 'ISSN',
  issue: 'issue',
  journal: 'container-title',
  language: true,
  location: 'publisher-place',
  note: true,
  number: 'issue',
  numpages: 'number-of-pages',
  pages: 'page',
  pmid: 'PMID',
  pmcid: 'PMCID',
  publisher: true,
  series: 'collection-title',
  title: true,
  url: 'URL',
  volume: true,
  year: 'issued:date-parts.0.0',
  month: 'issued:date-parts.0.1',
  day: 'issued:date-parts.0.2',
  crossref: false,
  keywords: false
};

const parseBibTeXProp = function (name, value) {
  if (!propMap.hasOwnProperty(name)) {
    logger.unmapped('[plugin-bibtex]', 'property', name);
    return undefined;
  } else if (propMap[name] === false) {
    return undefined;
  }

  const cslProp = propMap[name] === true ? name : propMap[name];

  const cslValue = ((name, value) => {
    switch (name) {
      case 'author':
      case 'editor':
        return parseBibtexNameList(value);

      case 'issued':
        return parseBibtexDate(value);

      case 'edition':
        return value;

      case 'issued:date-parts.0.1':
        return parseFloat(value) ? value : months.findIndex(month => month.test(value)) + 1;

      case 'page':
        return value.replace(/[—–]/, '-');

      case 'title':
        return parseBibtexRichText(value);

      default:
        return value.replace(/[{}]/g, '');
    }
  })(cslProp, value);

  return [cslProp, cslValue];
};

export { parseBibTeXProp as parse, parseBibTeXProp as default };