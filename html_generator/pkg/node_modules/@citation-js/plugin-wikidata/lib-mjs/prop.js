import { logger } from '@citation-js/core';
import { parse as parseNameString } from '@citation-js/name';
import { parse as parseDate } from '@citation-js/date';
import config from './config';
import types from './types';

const getSeriesOrdinal = ({
  P1545
}) => P1545 ? parseInt(P1545[0]) : -1;

const getStatedAs = qualifiers => [].concat(...[qualifiers.P1932, qualifiers.P1810].filter(Boolean));

const parseName = ({
  value,
  qualifiers
}) => {
  let [name] = getStatedAs(qualifiers);

  if (!name) {
    name = typeof value === 'string' ? value : getLabel(value);
  }

  name = name ? parseNameString(name) : {
    literal: name
  };
  name._ordinal = getSeriesOrdinal(qualifiers);
  return name;
};

const parseNames = values => {
  return values.map(parseName).sort((a, b) => a._ordinal - b._ordinal);
};

const getPlace = value => {
  const country = value.claims.P17[0].value;
  const shortNames = country.claims.P1813.filter(({
    qualifiers: {
      P31
    }
  }) => !P31 || P31[0] !== 'Q28840786');
  return getLabel(value) + ', ' + (shortNames[0] || country.claims.P1448[0]).value;
};

const getTitle = value => {
  return value.claims.P1476 ? value.claims.P1476[0].value : getLabel(value);
};

const parseKeywords = values => {
  return values.map(({
    value
  }) => getLabel(value)).join(',');
};

const parseDateRange = dates => ({
  'date-parts': dates.map(date => parseDate(date.value)).filter(date => date && date['date-parts']).map(date => date['date-parts'][0])
});

export function parseProp(prop, value, entity) {
  switch (prop) {
    case 'type':
      return parseType(value);

    case 'author':
    case 'director':
    case 'container-author':
    case 'collection-editor':
    case 'composer':
    case 'editor':
    case 'illustrator':
    case 'original-author':
    case 'recipient':
    case 'reviewed-author':
    case 'translator':
      return parseNames(value);

    case 'issued':
    case 'original-date':
      return parseDate(value);

    case 'event-date':
      return parseDateRange(value);

    case 'keyword':
      return parseKeywords(value);

    case 'container-title':
    case 'collection-title':
    case 'event':
    case 'medium':
    case 'publisher':
    case 'original-publisher':
      return getTitle(value);

    case 'event-place':
    case 'original-publisher-place':
    case 'publisher-place':
      return getPlace(value);

    case 'collection-number':
      return getSeriesOrdinal(value[0].qualifiers);

    case 'number-of-volumes':
      return value.length;

    default:
      return value;
  }
}
export function parseType(type) {
  if (!types[type]) {
    logger.unmapped('[plugin-wikidata]', 'publication type', type);
    return 'book';
  }

  return types[type];
}
export function getLabel(entity) {
  if (!entity) {
    return undefined;
  }

  const lang = config.langs.find(lang => entity.labels[lang]);
  return entity.labels[lang];
}
export { parseProp as parse, parseProp as default };