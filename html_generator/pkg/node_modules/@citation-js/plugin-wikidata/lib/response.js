"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillCache = fillCache;
exports.parse = parse;
exports.fillCacheAsync = fillCacheAsync;
exports.parseAsync = parseAsync;

var _wikidataSdk = require("wikidata-sdk");

var _api = require("./api");

var _id = require("./id");

const SIMPLIFY_OPTS = {
  keepQualifiers: true,
  timeConverter: 'simple-day'
};
const FETCH_PLACE = {
  P17: null
};
const FETCH_PUBLISHER = {
  P740: FETCH_PLACE,
  P159: FETCH_PLACE
};
const FETCH_ADDITIONAL = {
  P50: null,
  P57: null,
  P86: null,
  P98: null,
  P110: null,
  P655: null,
  P1817: null,
  P921: {
    P50: null
  },
  P407: null,
  P364: null,
  P123: FETCH_PUBLISHER,
  P629: {
    P50: null,
    P123: FETCH_PUBLISHER
  },
  P437: null,
  P186: null,
  P179: {
    P98: null
  },
  P1433: {
    P4745: {
      P276: FETCH_PLACE
    }
  },
  P361: {
    P50: null
  }
};

function flat(array, part) {
  array.push(...part);
  return array;
}

function collectAdditionalIds(entity, needed) {
  if (!needed) {
    return [];
  }

  entity._needed = Object.assign(entity._needed || {}, needed);
  return Object.keys(entity.claims).filter(prop => prop in needed).map(prop => entity.claims[prop].map(({
    value
  }) => value.id || value)).reduce(flat, []);
}

function completeResponse(entities, old) {
  if (!old) {
    let allIds = [];

    for (let id in entities) {
      const ids = collectAdditionalIds(entities[id], FETCH_ADDITIONAL);

      for (let id of ids) {
        if (!allIds.includes(id)) {
          allIds.push(id);
        }
      }
    }

    return allIds;
  }

  const ids = [];

  for (var id of old) {
    var entity = entities[id];

    if (!entity._needed) {
      continue;
    }

    for (var prop in entity.claims) {
      if (prop in entity._needed) {
        for (let claim of entity.claims[prop]) {
          if (claim.value && claim.value.id) {
            continue;
          }

          claim.value = entities[claim.value];
          ids.push(...collectAdditionalIds(claim.value, entity._needed[prop]));
        }
      }
    }

    delete entity._needed;
  }

  return ids;
}

function simplifyEntities(entities) {
  return _wikidataSdk.simplify.entities(entities, SIMPLIFY_OPTS);
}

function initLoopState(entities, cache) {
  return {
    needed: completeResponse(cache),
    incomplete: Object.keys(entities)
  };
}

function filterIdsAndGetUrls(needed, cache) {
  const shouldFetch = needed.filter((id, i) => !(id in cache) && needed.indexOf(id) === i);
  return (0, _id.parse)(shouldFetch);
}

function addItemsToCache(response, cache) {
  const {
    entities
  } = JSON.parse(response);
  Object.assign(cache, simplifyEntities(entities));
}

function updateLoopState(state, cache) {
  return {
    needed: completeResponse(cache, state.incomplete),
    incomplete: state.needed
  };
}

function finalizeItems(entities, cache) {
  return Object.keys(entities).map(id => cache[id]);
}

function fillCache(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);

  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    urls.map(url => addItemsToCache((0, _api.parse)(url), cache));
    state = updateLoopState(state, cache);
  }

  return cache;
}

function parse(entities) {
  const cache = fillCache(entities);
  return finalizeItems(entities, cache);
}

async function fillCacheAsync(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);

  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    await Promise.all(urls.map(async url => addItemsToCache((await (0, _api.parseAsync)(url)), cache)));
    state = updateLoopState(state, cache);
  }

  return cache;
}

async function parseAsync(entities) {
  const cache = await fillCacheAsync(entities);
  return finalizeItems(entities, cache);
}