"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseOld = parseOld;
exports.parseNew = parseNew;
exports.parseMixed = parseMixed;
exports.format = format;

var _core = require("@citation-js/core");

var _config = _interopRequireDefault(require("./config"));

var _spec = require("./spec");

var _converters = _interopRequireDefault(require("./converters"));

var _dataTypes = _interopRequireDefault(require("./dataTypes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LINE_MATCH = /^[A-Z][A-Z0-9] {2}-( |$)/;
const LINE_SPLIT = / {2}-(?: |$)/;
const TRANSLATORS = new Map();

function prepareTranslator(spec) {
  if (!TRANSLATORS.has(spec)) {
    for (let mapping of spec) {
      if (mapping.target in _dataTypes.default) {
        mapping.convert = _converters.default[_dataTypes.default[mapping.target]];
      }

      if (mapping.convert && mapping.convert.keepAll === true) {
        continue;
      }

      if (Array.isArray(mapping.source)) {
        if (mapping.convert) {
          const {
            toSource,
            toTarget
          } = mapping.convert;
          mapping.convert = {
            toTarget(...args) {
              return toTarget(_converters.default.ANY.toTarget(...args));
            },

            toSource(...args) {
              return _converters.default.ANY.toSource(toSource(...args));
            }

          };
        } else {
          mapping.convert = _converters.default.ANY;
        }
      }
    }

    TRANSLATORS.set(spec, new _core.util.Translator(spec));
  }

  return TRANSLATORS.get(spec);
}

function parse(text) {
  const entries = [];
  let lastEntry;
  let lastTag;

  for (let line of text.split(/\r?\n/)) {
    line = line.trim();

    if (!LINE_MATCH.test(line)) {
      if (lastEntry && lastTag) {
        lastEntry[lastTag] += ' ' + line;
      }

      continue;
    }

    const [tag, value] = line.split(LINE_SPLIT);

    switch (tag) {
      case 'ER':
        lastEntry = undefined;
        lastTag = undefined;
        break;

      case 'TY':
        lastEntry = {};
        entries.push(lastEntry);

      default:
        if (Array.isArray(lastEntry[tag])) {
          lastEntry[tag].push(value);
        } else {
          lastEntry[tag] = lastEntry[tag] ? [lastEntry[tag], value] : value;
        }

        lastTag = tag;
    }
  }

  return entries;
}

function parseOld(data) {
  return prepareTranslator(_spec.SPECS.old).convertToTarget(data);
}

function parseNew(data) {
  return prepareTranslator(_spec.SPECS.new).convertToTarget(data);
}

function parseMixed(data) {
  return prepareTranslator(_spec.SPECS.mixed).convertToTarget(data);
}

function format(data, {
  type,
  format = type || 'text'
} = {}) {
  const entries = data.map(prepareTranslator(_spec.SPECS[_config.default.outputSpec]).convertToSource);

  if (format === 'object') {
    return entries;
  }

  return entries.map(entry => {
    const tags = [];

    for (let tag in entry) {
      if (tag === 'TY') {
        continue;
      }

      tags.push(...[].concat(entry[tag]).map(value => `${tag}  - ${value.toString().replace(/(.{70})/g, '$1\n')}`));
    }

    tags.unshift(`TY  - ${entry.TY}`);
    tags.push('ER  - ');
    return tags.join('\n');
  }).join('\n');
}